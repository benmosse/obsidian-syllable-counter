/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SyllableCounterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  maxLinesToProcess: 500,
  updateDebounceInterval: 500,
  onlyVisibleRange: true,
  showZeroSyllables: false,
  verbosity: "verbose"
};
var SyllableCounterPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syllableMarkers = [];
    this.observer = null;
    this.styleEl = null;
    this.isProcessing = false;
    this.pendingUpdate = false;
  }
  async onload() {
    console.log("Loading Syllable Counter plugin");
    await this.loadSettings();
    this.updateSyllableCountsDebounced = (0, import_obsidian.debounce)(
      (view) => this.updateSyllableCounts(view),
      this.settings.updateDebounceInterval
    );
    this.loadStyles();
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor, view) => {
        if (view instanceof import_obsidian.MarkdownView) {
          this.updateSyllableCountsDebounced(view);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf && leaf.view instanceof import_obsidian.MarkdownView) {
          this.updateSyllableCountsDebounced(leaf.view);
        } else {
          this.clearSyllableMarkers();
        }
      })
    );
    this.registerDomEvent(document, "scroll", (0, import_obsidian.debounce)((e) => {
      const target = e.target;
      if (target && target.closest(".markdown-source-view")) {
        const activeView2 = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView2 && this.settings.onlyVisibleRange) {
          this.updateSyllableCountsDebounced(activeView2);
        }
      }
    }, 300));
    this.setupMutationObserver();
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      this.updateSyllableCountsDebounced(activeView);
    }
    this.addSettingTab(new SyllableCounterSettingTab(this.app, this));
  }
  onunload() {
    console.log("Unloading Syllable Counter plugin");
    this.clearSyllableMarkers();
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    if (this.styleEl && this.styleEl.parentNode) {
      this.styleEl.remove();
      this.styleEl = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateSyllableCountsDebounced = (0, import_obsidian.debounce)(
      (view) => this.updateSyllableCounts(view),
      this.settings.updateDebounceInterval
    );
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      this.updateSyllableCountsDebounced(activeView);
    }
  }
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "syllable-counter-styles";
    styleEl.textContent = `
            .syllable-marker {
                color: var(--text-muted);
                font-size: 12px;
                font-family: var(--font-monospace);
                position: absolute;
                right: 10px;
                opacity: 0.7;
                pointer-events: none;
                user-select: none;
                z-index: 1;
            }
        `;
    document.head.appendChild(styleEl);
    this.styleEl = styleEl;
  }
  setupMutationObserver() {
    this.observer = new MutationObserver((0, import_obsidian.debounce)((mutations) => {
      const activeView2 = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView2) return;
      const editorElement = activeView2.containerEl.querySelector(".cm-editor");
      if (!editorElement) return;
      const isRelevant = mutations.some((mutation) => {
        return mutation.type === "childList" && (editorElement.contains(mutation.target) || mutation.target === editorElement);
      });
      if (isRelevant) {
        this.updateSyllableCountsDebounced(activeView2);
      }
    }, 300));
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editorContainer = activeView.containerEl.querySelector(".markdown-source-view");
      if (editorContainer) {
        this.observer.observe(editorContainer, {
          childList: true,
          subtree: true,
          attributes: false,
          characterData: false
        });
      }
    }
  }
  clearSyllableMarkers() {
    try {
      this.syllableMarkers.forEach((marker) => {
        if (marker && marker.parentNode) {
          marker.remove();
        }
      });
    } catch (e) {
      console.error("Error clearing syllable markers:", e);
    }
    this.syllableMarkers = [];
  }
  getVisibleLineRange(editorElement) {
    if (!editorElement) return null;
    const editorRect = editorElement.getBoundingClientRect();
    const lineElements = editorElement.querySelectorAll(".cm-line");
    if (!lineElements || lineElements.length === 0) return null;
    let startLine = -1;
    let endLine = -1;
    for (let i = 0; i < lineElements.length; i++) {
      const lineRect = lineElements[i].getBoundingClientRect();
      const isVisible = lineRect.bottom >= editorRect.top - 100 && // Add some buffer
      lineRect.top <= editorRect.bottom + 100;
      if (isVisible) {
        if (startLine === -1) startLine = i;
        endLine = i;
      } else if (startLine !== -1 && lineRect.top > editorRect.bottom) {
        break;
      }
    }
    if (startLine === -1) return null;
    startLine = Math.max(0, startLine - 10);
    endLine = Math.min(lineElements.length - 1, endLine + 10);
    return { start: startLine, end: endLine };
  }
  async updateSyllableCounts(view) {
    if (this.isProcessing) {
      this.pendingUpdate = true;
      return;
    }
    this.isProcessing = true;
    this.pendingUpdate = false;
    try {
      this.clearSyllableMarkers();
      const editor = view.editor;
      if (!editor) {
        this.isProcessing = false;
        return;
      }
      const editorElement = view.containerEl.querySelector(".cm-editor");
      if (!editorElement) {
        this.isProcessing = false;
        return;
      }
      const lineElements = editorElement.querySelectorAll(".cm-line");
      if (!lineElements || lineElements.length === 0) {
        this.isProcessing = false;
        return;
      }
      let startLine = 0;
      let endLine = Math.min(lineElements.length - 1, this.settings.maxLinesToProcess - 1);
      if (this.settings.onlyVisibleRange) {
        const visibleRange = this.getVisibleLineRange(editorElement);
        if (visibleRange) {
          startLine = visibleRange.start;
          endLine = visibleRange.end;
          if (endLine - startLine + 1 > this.settings.maxLinesToProcess) {
            endLine = startLine + this.settings.maxLinesToProcess - 1;
          }
        }
      }
      const fragment = document.createDocumentFragment();
      const content = editor.getValue();
      const lines = content.split("\n");
      for (let index = startLine; index <= endLine; index++) {
        if (index >= lines.length || index >= lineElements.length) continue;
        const line = lines[index];
        const syllableCount = this.countSyllables(line);
        if (syllableCount > 0 || this.settings.showZeroSyllables) {
          const lineElement = lineElements[index];
          if (!lineElement) continue;
          const marker = document.createElement("div");
          marker.className = "syllable-marker";
          if (this.settings.verbosity === "verbose") {
            marker.textContent = `${syllableCount} ${syllableCount === 1 ? "syllable" : "syllables"}`;
          } else {
            marker.textContent = `${syllableCount}`;
          }
          if (lineElement.offsetTop !== void 0) {
            marker.style.top = `${lineElement.offsetTop}px`;
          }
          fragment.appendChild(marker);
          this.syllableMarkers.push(marker);
        }
      }
      editorElement.appendChild(fragment);
    } catch (e) {
      console.error("Error updating syllable counts:", e);
    } finally {
      this.isProcessing = false;
      if (this.pendingUpdate) {
        setTimeout(() => {
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (activeView) {
            this.updateSyllableCountsDebounced(activeView);
          }
        }, 50);
      }
    }
  }
  countSyllables(word) {
    try {
      word = word.toLowerCase().replace(/[^a-z]/g, " ").trim();
      if (!word) return 0;
      const words = word.split(/\s+/);
      let totalSyllables = 0;
      for (const w of words) {
        if (!w) continue;
        let syllables = 0;
        if (w.length === 1) {
          totalSyllables += 1;
          continue;
        }
        const vowels = "aeiouy";
        let isPrevVowel = false;
        for (let i = 0; i < w.length; i++) {
          const isVowel = vowels.includes(w[i]);
          if (isVowel && !isPrevVowel) {
            syllables++;
          }
          isPrevVowel = isVowel;
        }
        if (w.endsWith("e") && syllables > 1 && !w.endsWith("le")) {
          syllables--;
        }
        if (w.endsWith("le") && w.length > 2 && !vowels.includes(w[w.length - 3])) {
          syllables++;
        }
        if (syllables === 0) {
          syllables = 1;
        }
        totalSyllables += syllables;
      }
      return totalSyllables;
    } catch (e) {
      console.error("Error counting syllables:", e);
      return 0;
    }
  }
};
var SyllableCounterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Syllable Counter Settings" });
    new import_obsidian.Setting(containerEl).setName("Maximum Lines to Process").setDesc("Limit the number of lines to process for better performance").addSlider((slider) => slider.setLimits(100, 2e3, 100).setValue(this.plugin.settings.maxLinesToProcess).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxLinesToProcess = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Update Delay").setDesc("Delay in milliseconds before updating syllable counts after changes").addSlider((slider) => slider.setLimits(100, 2e3, 100).setValue(this.plugin.settings.updateDebounceInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.updateDebounceInterval = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Only Process Visible Range").setDesc("Only count syllables for visible lines (improves performance)").addToggle((toggle) => toggle.setValue(this.plugin.settings.onlyVisibleRange).onChange(async (value) => {
      this.plugin.settings.onlyVisibleRange = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Zero Syllable Lines").setDesc("Show syllable count for lines with zero syllables").addToggle((toggle) => toggle.setValue(this.plugin.settings.showZeroSyllables).onChange(async (value) => {
      this.plugin.settings.showZeroSyllables = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Verbosity").setDesc("Choose how syllable counts are displayed").addDropdown((dropdown) => dropdown.addOption("verbose", 'Verbose (e.g., "5 syllables")').addOption("terse", 'Terse (e.g., "5")').setValue(this.plugin.settings.verbosity).onChange(async (value) => {
      this.plugin.settings.verbosity = value;
      await this.plugin.saveSettings();
    }));
  }
};
